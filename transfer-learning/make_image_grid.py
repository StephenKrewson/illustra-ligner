"""
This code generates a quick visualization of the nearest K neighbors
for a matrix X of 2048-dimensional vectors that have been generated by
passing a group of images through a pretrained TensorFlow model and
extracting the penultimate layer.

USAGE: python make_image_grid.py <VECTORS_DIR> <NUM_NEIGHBORS>

Run in illustra-ligner directory from Anaconda Prompt in tensorflow environment

"""


import cv2
import glob
from imutils import build_montages
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import ImageGrid
import numpy as np
import random
from sklearn.neighbors import NearestNeighbors
import sys


# ensure user is passing in a directory of numpy arrays and a K value
if len(sys.argv) != 3:
	sys.exit("USAGE: python make_image_grid.py <VECTORS_DIR> <NUM_NEIGHBORS>")

try:
	# just stick with 39 + original = 40 for nice grid
	K = int(sys.argv[2])
except ValueError:
	sys.exit("<NUM_NEIGHBORS> must be a positive integer.")


# first load the arrays out of their files before shaping
# remember the corresponding path to each image
arrays = []
paths  = []

# iterator gives back everything that matches
for f in glob.iglob(sys.argv[1] + "/*npy"):
	arrays.append(np.load(f))
	
	# ASSUMES: within project, both /img and /vectors folders exist
	# consequenctly, image has same base name, minus .npy extension
	# we will also need to move up and over into the img/ directory
	path = f.rsplit('.', 1)[0]
	path = path.replace("vectors", "img")
	paths.append(path)

# shape should be N (images) x 2048
X = np.stack(arrays, axis=0)

# from tutorial: http://scikit-learn.org/stable/modules/neighbors.html
nbrs = NearestNeighbors(n_neighbors=int(sys.argv[2])).fit(X)
distances, indices = nbrs.kneighbors(X)

# pretty fast actually!
#print('\n'.join(paths))
#print(distances.shape)

# pick a random row from the matrix (TODO: parameterize this?)
idx = random.randint(0, X.shape[0])
print("idx =", idx)

# loop over the neighbors of this image and open them in OpenCV
# we will send these to montage 
images = []
nearest_nbrs = [y for (x,y) in sorted(zip(distances[idx],indices[idx]), key=lambda pair: pair[0])]

for nbr in nearest_nbrs:
	images.append(cv2.imread(paths[nbr]))

# construct a montage: first tuple is (width, height) then (columns, rows)
montages = build_montages(images, (128, 180), (10, 4))

for montage in montages:
	cv2.imshow("Montage", montage)
	cv2.waitKey(0)

# http://www.pyimagesearch.com/2017/05/29/montages-with-opencv/


# https://stackoverflow.com/questions/16628514/is-there-a-good-solution-for-space-efficiently-showing-multiple-images-in-pylab
# im = np.arange(100)
# im.shape = 10, 10
# images = [im for i in range(100)]

# fig = plt.figure(1, (4., 4.))
# grid = ImageGrid(fig, 111,
#                  nrows_ncols=(10, 10),
#                  axes_pad=0,
# )

# for i in range(100):
#     grid[i].imshow(images[i], cmap=plt.get_cmap('Greys_r'))  # The AxesGrid object work as a list of axes.
#     grid[i].axis('off')
# plt.show(block=True)