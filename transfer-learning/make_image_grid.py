"""
This code generates a quick visualization of the nearest 40 neighbors
for a matrix X of 2048-dimensional vectors that have been generated by
passing a group of images through a pretrained TensorFlow model and
extracting the penultimate layer.

USAGE: python make_image_grid.py <VECTORS_DIR>

Run in illustra-ligner directory from Anaconda Prompt in tensorflow environment

"""


import cv2
import glob
from imutils import build_montages
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import ImageGrid
import numpy as np
import random
from sklearn.neighbors import NearestNeighbors
import sys


# ensure user is passing in a directory of numpy arrays
if len(sys.argv) != 2:
	sys.exit("USAGE: python make_image_grid.py <VECTORS_DIR>")

# number of neighbors includes the image itself (4 x 10 grid works)
K = 40

# first load the arrays out of their files before shaping
# remember the corresponding path to each image
arrays = []
paths  = []

# iterator gives back everything that matches
for f in glob.iglob(sys.argv[1] + "/*npy"):
	arrays.append(np.load(f))
	
	# ASSUMES: within project, both /img and /vectors folders exist
	# consequenctly, image has same base name, minus .npy extension
	# we will also need to move up and over into the img/ directory
	path = f.rsplit('.', 1)[0]
	path = path.replace("vectors", "img")
	paths.append(path)

# shape should be N (images) x 2048
X = np.stack(arrays, axis=0)

# from tutorial: http://scikit-learn.org/stable/modules/neighbors.html
nbrs = NearestNeighbors(n_neighbors=K).fit(X)
distances, indices = nbrs.kneighbors(X)

# pick a random row from the matrix (TODO: parameterize this?)
idx = random.randint(0, X.shape[0])
print("idx =", idx)

# loop over the neighbors of this image and open them in OpenCV
# first image is img itself; we will send array to montage 
images = []
nearest_nbrs = [y for (x,y) in sorted(zip(distances[idx],indices[idx]), key=lambda pair: pair[0])]

for nbr in nearest_nbrs:
	images.append(cv2.imread(paths[nbr]))

# construct montage: first tuple (width, height) then (columns, rows)
# http://www.pyimagesearch.com/2017/05/29/montages-with-opencv/
montages = build_montages(images, (128, 180), (10, 4))
for montage in montages:
	cv2.imshow("Montage", montage)
	cv2.waitKey(0)
